const questions = [
    {
        question: "using System;\n                    \npublic class Foo\n{\n    public override string ToString() { return \"0\"; }\n    public static implicit operator string(Foo f) { return \"1\"; }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        Foo f = new Foo();\n        Console.Write(f);\n        Console.Write($\"{f}\");\n        Console.Write(f + \"\");\n        Console.Write((object)f);\n    }\n}",
        answer: "1010",
        explanation: "The class <code>Foo</code> defines 2 members - a <code>ToString()</code> method and an implicit conversion to string. The question is about which of the these is preferred in different cases.<br><br>In the first case, the implicit conversion is preferred because <code>Console.Write()</code> has an overload that takes a string. There also happens to be an overload taking <code>object</code>, but when resolving function overloads, the overload with the most specific types (string) is chosen.<br><br>In the second case, we are using string interpolation. String interpolation works with any object, and has a few rules for how the conversion is done. If we pass a custom formatter, that is used. Next, if the type implements <code>IFormattable</code>, that is used. Finally, we fall back to the <code>ToString()</code> method, which is guaranteed to exist for any object.<br><br>In the third case, the implicit conversion is used again. There is no addition operator between <code>Foo</code> and string, so the only thing the language can do to resolve this is cast one side to string.<br><br>In the final case, we explicitly cast to object. Now the operand exactly matches the overload of <code>Console.Write()</code> that takes an <code>object</code>. The only way to convert any <code>object</code> to a string is via its <code>ToString()</code> method.",
        hint: "In .NET, all objects have a <code>ToString()</code> method. String interpolation works with any type.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUAAkKOJJL1QGZ8N8AxAe3rwG89jL96A3AUzDACWcHtUwAGfABV6AZWCCoAcwAUASnzNqAdnwAiMboDc+AL5siHVJgBs+AQFsADgBsBAYwHBOjvgENg9GCiYsoM9PgAZuqaqDq6mEameGa45FQ0Vlos5oQY6DkaBcRhkfgAvPhQPADudIxqhkVEAML0UADO9M48AHQA6oLAPMpRjQSk+K0dXb0DnsMAJLrMESa6qmMTk22d3f2DwxH4iHrrmxNTu7MHysr0AEYAVjxuwKqjBSkmQA"
    },
    {
        question: "using System;\n\npublic class Foo&lt;T&gt; { }\n\npublic static class FooExt\n{\n    public static void Bar(this Foo&lt;int&gt; foo) { Console.Write(\"0\"); }\n    public static void Bar&lt;T&gt;(this Foo&lt;T&gt; foo) { Console.Write(\"1\"); }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        Foo&lt;int&gt; f = new Foo&lt;int&gt;();\n        f.Bar();\n        Baz(f);\n    }\n        \n    public static void Baz&lt;T&gt;(Foo&lt;T&gt; f)\n    {\n        f.Bar();\n    }\n}",
        answer: "01",
        explanation: "<code>FooExt</code> defines 2 overloaded extension methods on <code>Foo&lt;T&gt;</code>. The question is about which overload is chosen in 2 different cases. Extension method overloads are resolved entirely at compile time, and the resolution algorithm always prefers the overload with the most concrete/specific type. <br><br>In the first case, we know at compile time that we have <code>Foo&lt;int&gt;</code>. <code>Foo&lt;int&gt;</code> is more specific than <code>Foo&lt;T&gt;</code>, so we pick that corresponding overload.<br><br>In the second case, looking at the body of <code>Baz</code>, the only information the function has at compile time is that the input is of type <code>Foo&lt;T&gt;</code>, so there is only one possible choice of overload. In C#, generics are a feature of the runtime - they are not monomorphized.",
        hint: "Resolution of overloaded extension methods is done entirely at compile time.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAINiAxAe0oB4AVAPmIG9iBfPAk1TANlPQVqAUQAewPMzwBIIqT6kALMQBCAQzAAKYAAsAlgGchtPVGBMAZtQCULYgGFKUA5QA2AUwB0AdTB7g7poARAAMQdYA3Owycjz8qMrqYPQM2vpGVLSMxFaUtqyOzm5evv6BQZjhURy4NVwC8gDsktIx6OgyUrjS0pk0puY5xAC8xFDuAO7G/WapkTLSFp5JmvPd0uoAXpoWa9I1PTHcCgmqapspmn3Zu50LSyt7NWxAA"
    },
    {
        question: "using System;\nusing System.Runtime.InteropServices;\n                    \npublic class Program\n{\n    public struct Empty { }\n    public struct OneByte { byte a; }\n    \n    public static int Size(object obj)\n    {\n        return Marshal.SizeOf(obj);\n    }\n    \n    public static void Main()\n    {\n        Console.Write(Marshal.SizeOf&lt;Empty&gt;());\n        Console.Write(Marshal.SizeOf&lt;OneByte&gt;());\n        Console.Write(Size(new OneByte()));\n    }\n}",
        answer: "111",
        explanation: "In this question, we query the size in bytes of a few different objects.<br><br>In the first case, the size is 1 byte, because .NET has no zero-sized types, and 1 is the minimum.<br><br>In the second case, the size is again 1 byte, because the contains 1 byte, which meets the minimum size.<br><br>In the final case, the size is also 1 byte. Casting to object doesn't erase the type information, it just boxes the struct (copies it to the heap). <code>Marshal.TypeOf(object)</code> uses the runtime type information of the boxed struct to return the correct size. You can read more about boxing <a href=\"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing\">on MSDN.</a>",
        hint: "In .NET, all objects implement a <code>GetType()</code> method. Also, there are no zero-sized types.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUKgBgAJVMA6AJWmAEsBbAUzIEkpgGwB7ABwGUOAbjQDGDAM4BuPAEhZsvKgDMJdCUwB2PAG9pMjOhlaZ0gMKcoYzgBsmAdTA12ACjE0AXg04AzJzTYBKfylcWTMLazsHZwBZAEMwMQALWKsyXncGAHkvAB4/YAA+J0Dg+RDTc0sbMntHBhcM7ycAI05rEuMwqsi6pziE5NT0j2yc1usijvLOyoiaqPrXDybhZLAp0Nnq2pj4pJS0jNHV+MmgmQBfPAugA==="
    },
    {
        question: "using System;\n\npublic struct FooStruct\n{\n    private int count;\n    public int Increment =&gt; ++count;\n}\n\npublic class FooClass\n{\n    private int count;\n    public int Increment =&gt; ++count;\n}\n\npublic class Program\n{\n    public static readonly FooStruct a = new();\n    public static FooStruct b = new();\n    \n    public static readonly FooClass c = new();\n    public static FooClass d = new();\n\n    public static void Main()\n    {\n        Console.Write(a.Increment);\n        Console.Write(a.Increment);\n        \n        Console.Write(b.Increment);\n        Console.Write(b.Increment);\n        \n        Console.Write(c.Increment);\n        Console.Write(c.Increment);\n        \n        Console.Write(d.Increment);\n        Console.Write(d.Increment);\n    }\n}",
        answer: "11121212",
        explanation: "This question highlights a feature of C# called <a href=\"https://devblogs.microsoft.com/premier-developer/avoiding-struct-and-readonly-reference-performance-pitfalls-with-errorprone-net/\">defensive copy</a>, which ensures that mutations on value types referenced through read-only variables have no effect on the original value. <br><br>For the objects <code>b</code>, <code>c</code>, and <code>d</code>, defensive copy has no effect, as we either have a reference type (a class) or a mutable value type field (a struct), so we print \"12\".<br><br>However, for the object <code>a</code> defensive copy kicks in, as we are trying to mutate a read-only value type field. Thus, both evaluations of <code>a.Increment</code> make a copy of the original struct and mutate this copy. The result is printing \"11\".<br><br>In all cases, the original structs are zero-initialized.",
        hint: "If we changed all <code>struct</code>s in the code to <code>class</code>es, the output of the program would change.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAIBnYSAY2GIDEB7egZQomrwG89ifiAHMAEsAbgENgAU2KCoNSvWjAA3N15Fps4gEkolMBIC2EzQF4AfMUSJ5ilbgC+eAiQx1GAYQA2o0qU6qeARFxKRk5BVk7XmJ1MO1dfSNTCysbSLxHfFx1V1RMAHZ/XGiczAA2Yn1ROHooTwBPN2ZWamJRYhNiKAkAdwAKAEootRdyppYqGgAjDq7eweGePABIUoqqmrrGhnovH1JiSlnu/qGAmNGKnb3fYjhj+bOskvR0c65i6N53WtJ6TwkADoAOpCSR9USAnR6QzGYBPL7fX7/IGgwTgyHQxJwp7LZbnaI/KB/AEgsESPpTKEJWGyBGI4hEkmo8mU6kwpLwux4lbLJkosnoimUdnYumLL780lo8EirG0rm83lSllCvpwUUK+mIlWC8Ea+Wc7XETL2IA="
    },
    {
        question: "using System;\n\npublic struct Foo\n{\n    public int num;\n    public void Set() { num = 1; }\n}\n\npublic class Program\n{\n    public static void Bar(in Foo f)\n    {\n        f.Set();\n        Console.Write(f.num);\n    }\n    \n    public static void Baz(Foo f)\n    {\n        f.Set();\n        Console.Write(f.num);\n    }\n\n    static void Main()\n    {\n        Foo bar = new Foo();\n        Bar(bar);\n        Baz(bar);\n    }\n}",
        answer: "01",
        explanation: "This question highlights a feature of C# called <a href=\"https://devblogs.microsoft.com/premier-developer/avoiding-struct-and-readonly-reference-performance-pitfalls-with-errorprone-net/\">defensive copy</a>, which ensures that mutations on value types referenced through read-only variables have no effect on the original value. <br><br>In the function <code>Bar</code>, when we use <code>Set()</code> to mutate the input struct, a hidden copy of the struct is made, and this copy is what is mutated. Thus the first <code>Console.Write</code> prints 0. In the second case, this copy does not occur as the input is not read-only, so we print 1.<br><br>If <code>Foo</code> had been a reference type (a class) instead of a value type (a struct), this program would have printed \"11\".",
        hint: "If we changed <code>Foo</code> from a <code>struct</code> to a <code>class</code>, the output of the program would change.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAIBnYSAY2GIDEB7evAbz2PeKOIEsoaoIAWwDcbDl1QAWYgGUApsAAUASmLNiAwcQC8xTMOIBfPMfy4J6TpgDsLMewmYAbJ2kAhAIZhFvOo2IAZsr2aiEcgQB08krKorjh4QDC9FCk9AA2chEA6mDcwHKKARGasSGm4SGOLlLEngBeigz0gcHxHKztCZHRKnHd7MmpGVm5+YXFpf0cplXOrsQAsh68KiGdA34tAEZeOhpyAO5bfWEcnt67YGVdCQ2KVzfhpoZAA"
    },
    {
        question: "using System;\n\npublic struct Foo\n{\n    public Foo()\n    {\n        Console.Write(\"0\");\n    }\n}\n\npublic class Program\n{\n    public static Foo bar;\n    public static Foo baz = new Foo();\n\n    public static void Main()\n    {\n        Foo bom = new Foo();\n        bom = bar;\n        bom = baz;\n    }\n}",
        answer: "00",
        explanation: "Parameterless struct constructors are a relatively new feature added in C# 10. They must be called explicitly to trigger, thus we only print \"0\" twice.",
        hint: "Struct fields are zero-initialized by default.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAIBnYSAY2GIDEB7evAbz2PeKLsYAoBKNh1a4Oo4gGF6UUvQA2AUwB0AdTABLYPJ4AiAAza+AbkHsAvnnP5cXDJ0wB2Fic4lUmAGzd6xAEYBDMGMRDhsPL18/AC9iAF5iKHkAdy9+IOcMdGdhMQ4Gbx96AFtY+KSUo2dRAuK4/0DKjmqS/0ig0UtTIA"
    },
    {
        question: "using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string foo = null;\n        if (foo is string bar) Console.Write(\"0\");\n        if (foo is string) Console.Write(\"1\");\n        if (foo is null) Console.Write(\"2\");\n        if (foo is var baz) Console.Write(\"3\");\n    }\n}",
        answer: "23",
        explanation: "In this question we pattern match on a null-valued string with 4 different patterns.<br><br>The first 2 patterns do not match, as pattern matching on a speficic type always inserts an implicit null-check. <br><br>The third pattern matches because foo is, in fact, null. <br><br>The final pattern also matches, because <code>var</code> patterns are special and match any value, including null. <code>var</code> patterns are not super useful in isolation, but can be combined with other patterns, like so:<br><pre><code class=\"language-csharp\"><br>public struct Foo<br>{<br>    public string bar;<br>}<br><br>static void Main()<br>{<br>    var foo = new Foo();<br>    if (foo is Foo { bar: var boo })<br>    {<br>        ...<br>    }<br>}<br></code></pre>",
        hint: "Pattern matching on a <b>specific</b> type inserts an implicit null-check.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAINTMB2PAbz2PtPXTodtwY/IAZiAzAe37EAvMSgQANhIDcLTsQCWvYgAoBQhQGduxAEYBDMAEpiAYX5RN/CQFMAdAHUwC4DZUAiLu6Oz28xcpqgoraqJhcJuaW1vZOLm7umN6+/gGq6iFikhKRFla2js6uHujJcpxK6cFaxABuhnr6AF650QVxxe6EZX70AL54fUA="
    },
    {
        question: "using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string foo = null;\n        if (foo is string) Console.Write(\"0\");\n        if (foo is not string or null) Console.Write(\"1\");\n        if (foo is not string and null) Console.Write(\"2\");\n        if (foo is not null and string) Console.Write(\"3\");\n        if (foo is string or null) Console.Write(\"4\");\n    }\n}",
        answer: "124",
        explanation: "This question shows some unintuitive quirks of pattern matching. Let's go through each line 1-by-1.<br><br><code>(foo is string)</code> checks that <code>foo</code> is a non-null string. Type-based pattern matches include an implicit null-check. <code>foo</code> is null, so no output here.<br><br><code>foo is not string or null</code> means:<br><code>(foo is not string)</code> OR <code>(foo is null)</code><br>The first part is true, since foo is null. The second part is also true. <code>true || true</code> is true, so we print \"1\".<br><br><code>foo is not string and null</code> is like the previous case, but with \"and\" instead of \"or\". <code>true && true</code> is true, so we print \"2\".<br><br><code>foo is not null and string</code> means:<br><code>(foo is not null)</code> AND <code>(foo is string)</code>.<br>The first part is true. The second part is false, because <code>foo</code> is null. <code>true && false</code> is false, so no output.<br><br><code>foo is string or null</code> means:<br><code>(foo is string)</code> OR <code>(foo is null)</code>.<br>The first part is again false. The second part is true. <code>false || true </code> is true, so we print \"4\".<br><br>The final output is \"124\".",
        hint: "<code>(foo is not string and null)</code> and <code>(foo is not null and string)</code> mean very different things. Type-based pattern matching includes implicit null-checks.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAINTMB2PAbz2PtPXTwEhbcHPyAGYgMwD2A4gF5iUCABtJAblYsAln2IAKQcIUBnHgEpiAYQFRNAyQFMAdAHUwC4GZUAibo51zcLRcrVDiW8QLAPMQCYOJSknqGxqaWNnYOjpiu7p5Kqup+2lCBwQCGUHDh0lFGJubWtvZO6Cl0XPTpPhrZuRLSxAVFqJjcpTEV8dWOhHUeXhm+/j28ocWRBmWxlQlOACxjnAC+eFtAA==="
    },
    {
        question: "using System;\n                    \npublic class Program\n{\n    interface IFoo\n    {\n        void Bar(int a = 1);\n    }\n    \n    public class Baz : IFoo\n    {\n        public void Bar(int a = 2) { Console.Write(a); }\n    }\n    \n    public static void Main()\n    {\n        new Baz().Bar();\n    }\n}",
        answer: "2",
        explanation: "Default parameter values on interfaces are bit special. They are not enforced on implementors, so the only time they are relevant is when you are calling a method directly on an interface type, like so:<br><pre><code><br>IFoo foo = new Baz();<br>foo.Bar(); // Prints 1<br></code></pre>",
        hint: "Think about what would happen if we were implementing multiple interfaces that define the same method, but with different default parameters.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUASEML1QGYACDSzAdjwG898BLKYAUzADMBDAY3bkAkgDEA9mKaMC+VABZyAIR5gAFK2Dke5ALzlMASgDc+JgF8mTMpXRKeAL3Ihh4yQWmFr8u2o1bd5OgG5PTkAMJiUADOYgA27AB0AOpgzByqPMbkFgQ5pgQY6FJM+FDsAO529qoGCcpqxuZ4ZkA==="
    },
    {
        question: "using System;\n                    \npublic class Program\n{\n    struct Foo : IDisposable\n    {\n        public int id;\n        \n        public void Dispose()\n        {\n            if (this.id != 0)\n            {\n                Console.Write(\"0\");\n            }\n            this.id = 0;\n        }\n    }\n    \n    public static void Main()\n    {\n        var baz = new Foo();\n        baz.id = 1;\n        \n        using (baz)\n        {\n            Console.Write(baz.id);\n        }\n        \n        Console.Write(baz.id);\n    }\n}",
        answer: "101",
        explanation: "The <code>using</code> statement will generate code that boxes the input struct before calling <code>Dispose</code>, by casting it to <code>IDisposable</code>. Boxing a struct involves copying it to the heap. Thus, a copy is disposed, not the original struct. The desugared program looks like this:<br><pre><code><br>Foo foo = default(Foo);<br>foo.id = 1; // foo.id == 1<br>Foo foo2 = foo; // foo2.id == 1<br>try<br>{<br>    Console.Write(foo.id); // print \"1\"<br>}<br>finally<br>{<br>    // a copy of foo2 is made and disposed<br>    // the dispose method prints \"0\"<br>    ((IDisposable)foo2).Dispose();<br>}<br>Console.Write(foo.id); // print \"1\", as foo.id was never modified<br></code></pre><br><br>Don't use <code>using</code> statements with disposable value types - it's a footgun.",
        hint: "<code>using</code> statements <b>require</b> the operand to implement <code>IDisposable</code>.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUASEML1QGYACDSzAdjwG898BnYSAY2HIDEB7X8iHIBJACIBLZgAdezAIYAjADYBTJowL4y5cVC7i4Abib4T21ABZyE6bJUAKAJQmNRcQDNy94AAtJAOgNyAEIAXnIABmdNfFciAGFeKGZeVX8AdTBxYAcAIgjcx2MYgF8TfF8AoPCI4sIyggbTAgx0dRMANzkwcgU5AC9ycKgVAHcefic6/D7+wLgh8kxpswivWejCOPxE5NSVDKyc+1n5opMG8ivrq5NdlLTM7IdTg3PGvBKgA="
    },
    {
        question: "using System;\nusing System;\n\nclass Program\n{\n    public static bool GetNum(bool useDecimal, out object val)\n    {\n        if (useDecimal)\n        {\n            val = 1M;\n            return true;\n        }\n        else\n        {\n            val = 2;\n            return false;\n        }\n    }\n    \n    public static void Main()\n    {\n        try\n        {\n            object result;\n            bool isDecimal = GetNum(true, out result);\n            decimal amount = (decimal)(isDecimal ? result : 0);\n            Console.Write(amount);\n            \n            isDecimal = GetNum(false, out result);\n            amount = (decimal)(isDecimal ? result : 0);\n            Console.Write(amount);\n        }\n        catch\n        {\n            Console.Write(\"3\");\n        }\n    }\n}",
        answer: "13",
        explanation: "Every time the compiler encounters a ternary expression, it must determine the type of each branch, and these must match. The type of the branches is determined only using information in the ternary expression, nothing outside of it. On top of this, a 0 literal is by default an integer. Thus the choices for types of the branches in both ternary expressions is between <code>int</code> and <code>object</code>. Every <code>int</code> is convertible to object, but not vice-versa, so the compiler chooses <code>object</code>. The first ternary is equivalent to:<br><pre><code><br>decimal amount = (decimal)(isDecimal ? result : (object)((int)0));<br></code></pre> In the first ternary expression, <code>GetNum</code> returns a decimal, which is then boxed (copied to the heap) and casted to decimal. This works fine, so we print \"1\".<br><br>In the next ternary expression, <code>GetNum</code> returns a integer, but we take the false-branch of the ternary, which returns a boxed integer. There is no unboxing conversion from integer to decimal, so this throws an invalid cast exception, and we print \"3\".<br><br>More info on <a href=\"https://learn.microsoft.com/en-us/archive/blogs/ericlippert/representation-and-identity\">boxing here</a>, and on <a href=\"https://learn.microsoft.com/en-us/archive/blogs/ericlippert/cast-operators-do-not-obey-the-distributive-law\">this specific program here</a>.",
        hint: "Both branches of a ternary expression must evaluate to the same type.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUHjAAlUwHY8BvPASFQGZjMA2QgIwHt2AbQgcQFNgAOQgBbABQduhCAGd+AEX4BjAJaiAhlxiF2EYLtYArFQYBuWgJQ0quatVUAzQuLmKV6qzWq371CzwAvISYALIA3N60pITAkPyRdtQAvt78XPLevvYBhMHoiX6oMY5a8oUpNKl2eIR1xOjotfXZcQCeWVHsxqaEYPyyEFzAFdRSPKqySmqaQXyCIhJxEPw6egb9g8OWo3Aes4QaonpQBsHiezNW4pPTnjwA/H0DQwYghAAMO1EAwuxQsm4/AAdAB1MCqYD8cRHE7Ab5JahRW77LR5ebCMTiUoZVa6fTPLbw0aw6BnFyXe6WG5TVGPQmvQjvL6jP4AoFgiFQmHHMkI+zVezKDTAZQAC06iLZgK4IPBkOhACI6IqdkiktV6oRqskgA=="
    },
    {
        question: "using System;\n\npublic class Foo\n{\n    public static int count;\n    public Foo() { count++; }\n}\n\npublic class Program\n{\n    public static Foo baz = new Foo();\n    \n    public static void Main()\n    {\n        new Program();\n\n        new Foo();\n        \n        Console.Write(Foo.count);\n    }\n}",
        answer: "1",
        explanation: "If none of the static fields in a type are used, no static field initializer will be executed for that type. We do use <code>Program</code> on the first line of <code>Main</code>, but we never refer to any static fields, so the program prints \"1\". If we had written something like <code>baz = baz;</code>, the program would print \"2\".",
        hint: "When exactly are static fields initialized?",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAINiAxAe0rwG89jHSTVMA2YgSymGIGNK0YAG4GTIhWoAKAJTFa/QT0SJhxAL55N+XBLKsA7HTGM97SZWIAjAIYAvYgF5iUAKYB3C7NG4mxE6To6AH0vn5Mbp5UlN4BfnFMAMKUUADOlAA2rgB0AOpgnMCuUtHZAkIyPn7a6kA="
    },
    {
        question: "using System;\n\npublic class Foo&lt;T&gt;\n{\n    public void Bar() { Console.Write(\"0\"); }\n}\n\npublic static class FooExt\n{\n    public static void Bar&lt;T&gt;(this Foo&lt;T&gt; foo) { Console.Write(\"1\"); }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        Foo&lt;int&gt; f = new Foo&lt;int&gt;();\n        f.Bar();\n    }\n}",
        answer: "0",
        explanation: "The question is asking which method is preferred if you have an extension method and inherent method that are equally good choices. In this case, the inherent method is preferred, as it is considered more specific. <br><br>Eric Lippert describes the behavior by describing a <a href=\"https://ericlippert.com/2013/12/23/closer-is-better/\">\"closeness\" heuristic</a>.",
        hint: "The various mechanisms in C# that resolve ambiguity tend to prefer the most specific/concrete choice.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAINiAxAe0oB4AVAPjwG89j3STUAWYgIQCGYABQBKYs2IBhSlADOlADYBTAHQB1MAEtgy4QCIADPtEBuYgF88V/LiKlMANlLoK1AKIAPYCzYd7qE6kvIJg9AzCwAAWWnJutIzEAGbU4pIy8kpqmjp6+pgm5jY2BFyugQDsLACQfuwY6HUSTRzxNFpQwAzJxAC8xFDKAO5tHV1ipi0cSaqhE03FQA==="
    },
    {
        question: "using System;\nusing System.Collections;\n\npublic class Foo : IEnumerable\n{\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return new int[] { 0 }.GetEnumerator();\n    }\n\n    public IEnumerator GetEnumerator()\n    {\n        return new int[] { 1 }.GetEnumerator();\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        foreach (var f in new Foo())\n            Console.Write(f);\n        \n        foreach (var f in (IEnumerable)new Foo())\n            Console.Write(f);\n    }\n}",
        answer: "10",
        explanation: "The class <code>Foo</code> implements the interface <code>IEnumerable</code> with 2 methods - 1 implicit implementation and 1 explicit implementation. The reason these 2 mechanisms of implementing interfaces exist, is to handle cases where multiple interfaces define the same members. You can either have 1 implicit implementation binding to multiple interfaces, or several explicit implementations binding to each their interface. In this case, we only have 1 interface, but C# still allows us to implement it with both mechanisms. The implementations will just overlap.<br><br>The next important piece of information is that <code>foreach</code> uses <a href=\"https://im5tu.io/article/2022/01/things-you-might-not-know-about-csharp-duck-typing/\">duck typing</a>. In other words, the <code>foreach</code> construct doesn't care that our type implements <code>IEnumerable</code>, it's completely irrelevant. All it requires is a method called <code>GetEnumerator</code> which returns an <code>IEnumerator</code>.<br><br>The question thus boils down to this: Which of 2 the implementations is preferred in these 2 cases:<br><pre><code><br>(new Foo()).GetEnumerator()<br>((IEnumerable)new Foo()).GetEnumerator()<br></code></pre><br>In the first case, we choose the implicit implementation as it is considered more specific (or \"closer\" <a href=\"https://ericlippert.com/2013/12/23/closer-is-better/\">in the words of Eric Lippert</a>) - we are talking about the concrete <code>Foo</code> type after all. <br><br>In the second case, there is only 1 possible choice, as neither of the implementations are virtual. We've thrown away the type of <code>Foo</code> for the purposes of compile time analysis, and only have an <code>IEnumerable</code>. The call is thus resolved to the explicit implementation at compile time.",
        hint: "In C#, the <code>foreach</code> construct is duck-typed, and doesn't care about which interfaces the operand implements.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUKgBgAJVMA6AYQHsAbGgUwGNgBLKqAZwG489UBmEuiIAxKlSIgSmfngDeeIkqIBJAKJQIAW3pgAhsCphp/MgHF6wDdt0GjACgCUi5QtzKPJAOxEo9AO5ELFDAANoAukRyRMQAvuaW1jr6hmBOPO7KsbyZSgKqSbapRBZWmsl2ac65US6e3r4BQSERUUSYRPGlhSkOjhke2bhDfIIY0l7yAJB1QuizbvVKAGZG9HqMABZE9gBuesbLzY2BYlRO1Uue1Jy09GQA6mAswPT2y/2zHl/Kq2DrWx2+0Ox3spH4jj8p3EFx+9RuHDuj2er3enxqQ1iQA=="
    },
    {
        question: "using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string x = new string(new char[0]);\n        string y = new string(new char[0]);\n        if (object.ReferenceEquals(x, y))\n            Console.Write(1);\n        else\n            Console.Write(0);\n    }\n}",
        answer: "1",
        explanation: "This question shows an optimization that (to my knowledge) technically violates the spec. However, this optimization is present in every major runtime including Mono and CoreCLR. The code that constructs strings will check if the array is 0-length. If so, instead of creating a new object, it will return a reference to a static \"empty string\" field. You can see this <a href=\"https://github.com/dotnet/runtime/blob/v9.0.0/src/libraries/System.Private.CoreLib/src/System/String.cs#L79-L80\">behavior here</a>.",
        hint: "If you change the array lengths to 1, the programs output will change.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAINTMB2PAbzwEgN17bc6HMAGYgD2IF5iUAKYB3chwAUwsQGMAFgEMwAbQ4BdAJQBueuy4BPfoNHipJ+UtWadrOgEsAZsQkB7AEYArITOAA6AEpCDkJgQlAyQgCiAI4QCgA2AM4S3DDE+hoaunQAwi5QiS7xQr4A6mB2wEISmNq6QklC2XkFRSXlldUcdawAvni9QA="
    },
    {
        question: "using System;\n\npublic class Program\n{\n    public static void Foo&lt;T&gt;()\n        where T : new()\n    {\n        T t = new T();\n        if (typeof(T) == t.GetType())\n            Console.Write(\"0\");\n        else\n            Console.Write(\"1\");\n    }\n    \n    public static void Main()\n    {\n        try\n        {\n            Foo&lt;int&gt;();\n            Foo&lt;int?&gt;();\n        }\n        catch\n        {\n            Console.Write(\"2\");\n        }\n    }\n}",
        answer: "02",
        explanation: "The first call to <code>Foo</code> works completely as you'd expect and prints \"0\". The default constructor for an <code>int</code> just produces the value 0.<br><br>The second call uses a <b>nullable</b> int as the generic type. Default constructing a nullable int like so: <code>var a = new int?();</code> will simply produce the value <code>null</code>. We then try to call <code>t.GetType()</code>, but <code>t</code> is <code>null</code>, so the function throws a null reference exception, and we enter the exception handler, printing \"2\".",
        hint: "<code>int?</code> denotes a nullable <code>int</code>. What do you get if you call the default constructor for a nullable <code>int</code>?",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAINTMB2PAbzwEgjyA2UgFmIDEB7LgHgBUAfAAoAlPToB3ABYBTMLOL9iIYlFmSx9Wrjp1lwYgF41GpWIDcEgJYAzYsOABPAA6yut4f1HGTwAHQA4rLA/K6yYuK6egDCXFAAzlwANrL+AOpg1sARAEQADLmiVtGyyQmyEnRxiSlpmdl5mEUldAC+9PQY6NoSwGBOEjp6dNx81lDAIsVVY7wTwAD8063tEgDGAIbA69JDVTVJqRlZOcK56C0SHbo3bUA"
    },
    {
        question: "using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.Write((int)Math.Round(-0.5));\n        Console.Write((int)Math.Round(0.5));\n        Console.Write((int)Math.Round(1.5));\n    }\n}",
        answer: "002",
        explanation: "C# uses the rounding mode <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.midpointrounding?view=net-9.0#system-midpointrounding-toeven\"><code>MidpointRounding.ToEven</code></a> by default, also known as Banker's rounding. Midpoint values are rounded to the nearest even number.",
        hint: "The question is asking about the default rounding mode used by C#. The answer is strange but not uncommon.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AZgAINTMB2PAbzwEgN17bc66BhAeygGdOAbAKYA6AOpgAlsEEAKGRKjAAlAFkAhsAAWwgEqdocGQFoADMICsSpQG56HbnyFjJ0uQuXqtu/VENnLNnZcvAIi4lKy8oqqGtp6BjKYFla2rAC+eGlAA="
    },
    {
        question: "using System;\n                    \npublic class Program\n{\n    public enum Foo { A = 1, B = 2 }\n    \n    public static void Bar(Foo a) { Console.Write(\"0\"); }\n    public static void Bar(object a) { Console.Write(\"1\"); }\n    \n    public static void Main()\n    {\n        Bar(0);\n        Bar(1);\n        Bar((object)(Foo.A));\n    }\n}",
        answer: "011",
        explanation: "This is a quirk of the language. There is always an implicit conversion from 0 (and only 0) to any enum. The specs' section 6.1.3 says \"An implicit enumeration conversion permits the decimal-integer-literal 0 to be converted to any enum-type and to any nullable-type whose underlying type is an enum-type\". Therefore, the first statement picks the enum-typed overload of <code>Bar</code>, and 2 next statements picks the object-typed overload.",
        hint: "0 is a special case for enum conversion.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUASEML1QGYACDSzAdjwG898zyBTKCAW3IDEB7PuXrkAguQC85TDHIAhCeXTkAvkyYtUmAGyUALHICGYABT9BBgJRDyAYT5QAznwA2rAHQB1MAEtgrYwBEAAwBFgDcKuoUmjqo+rJGxnwARgBWrADGwOSW1naOLu5evv4BmKERqgTq6OhMjAT4CSZB4UxNiZhtjc3GSWmZwBamAm4iFt34VcpAA=="
    },
    {
        question: "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class Foo\n{\n    public static IEnumerable&lt;T&gt; Where&lt;T&gt;(\n        this IEnumerable&lt;T&gt; src,\n        Func&lt;T, bool&gt; pred)\n    {\n        yield return default;\n    }\n    \n    public static IEnumerator&lt;int&gt; GetEnumerator&lt;T&gt;(this T src)\n    {\n        return ((IEnumerable&lt;int&gt;)new int[] { 4 }).GetEnumerator();\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        int[] arr = new int[] { 1, 2, 3 };\n        \n        var filtered = \n            from x in arr\n            where x &gt; 1\n            select x;\n        \n        foreach (var num in filtered)\n            Console.Write(num);\n        \n        foreach (var num in \"5\")\n            Console.Write(num);\n    }\n}",
        answer: "05",
        explanation: "To explain the behavior observed in the question, you must know 2 things:<br>- Both LINQ's query syntax and <code>foreach</code> statements are just syntax sugar, and use <a href=\"https://im5tu.io/article/2022/01/things-you-might-not-know-about-csharp-duck-typing/\">duck-typing</a>. They do not rely on specific interfaces being implemented, they only require methods with a specific signature to exist.<br>- When resolving overloaded function calls, the <a href=\"https://ericlippert.com/2013/12/23/closer-is-better/\">\"closest\"</a> one is picked. We prefer inherent methods over extension methods, and we prefer extension methods in our current namespace over extension methods defined elsewhere.<br><br>In the query syntax expression, there <code>where</code> keyword desugars to a call to our extension method <code>.Where()</code>. This method returns a single-element iterator, that element being 0, the default value for integers. The reason <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where?view=net-9.0\">the existing <code>.Where()</code> extension method defined in System.Linq</a> isn't used, is because ours is \"closer\" - in the current namespace. So, <code>filtered</code> refers to an iterator containing only the integer 0.<br><br>Next, we iterate over this iterator with a <code>foreach</code> statement. This (roughly) desugars to:<br><pre><code><br>IEnumerable&lt;int&gt; filtered = ...;<br>IEnumerator&lt;int&gt; enumerator = filtered.GetEnumerator();<br>while (enumerator.MoveNext())<br>{<br>    int current = enumerator.Current;<br>    Console.Write(current);<br>}<br></code></pre> The <code>GetEnumerator()</code> call does <b>not</b> use our extension method, as there is a better candidate: <code>IEnumerable&lt;T&gt;</code> has an <a href =\"https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable.getenumerator?view=net-9.0\">inherent method called <code>GetEnumerator()</code></a>. So we iterate normally, and print \"0\".<br><br>Finally, we iterate over the string <code>\"5\"</code> using a <code>foreach</code>. This again does not pick our <code>GetEnumerator()</code> extension method, as <code>string</code> already has an <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.string.getenumerator?view=net-8.0\">inherent method with the same name</a>. The behavior is thus to iterate over the characters of <code>\"5\"</code>, so we print \"5\".<br><br>If we had changed the final loop to:<br><pre><code><br>foreach (var num in 5)<br>    Console.Write(num);<br></code></pre> The program would have printed \"04\". As integers have no <code>GetEnumerator()</code> method, our extension method would have been used.",
        hint: "LINQ query syntax uses duck-typing, as do <code>foreach</code> statements.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUKgBgAJVMAWAbj0JMwDoAZASygEcrdqBmWgNhPREAYgHsReAN54iMkj1L9SXADwAVAHxEA6gAsApmD1r1ACjwBIc8B1MAzrRUaitsAGMYF86gCsamEQAjMQAbTQAHQzgASmlZKVxZRNpMEgB2Ijg9ADMAQwhg4A5EgF8LC1R5TH4ASQBRKAgAWwMc4BEwZRZgTQBxPWB6ppa2jo0TazsiVWc3GNxzeMtUdJMTJU6obqioPQB3Ii6AbQBdIgkiMiJiqLo+gYbmsFb2kyiOc1LcT+4BWlTJcrodAWRbmI6nHJgMBEAC8RB2+3BZyImH86H8PGK73MngAbpCiFkmAUDHo4LCiJ5zFkwCJGkQAB4HKBESFgKm7fSGRlETQ4eaWWx6YJ6VzARnYzxZdp6HKuHREEz46EPZmE4nAUnRKkAYREUFsIhFdC0YCYmpMDzenilMrlCqVBNVLCIACJvK65pZzHqDUa9CazRare9PsUgA==="
    },
    {
        question: "using System;\nusing System.Runtime.InteropServices;\n                    \npublic class Program\n{	\n    public static void Main()\n    {\n        Console.Write(sizeof(int));\n        Console.Write(Marshal.SizeOf&lt;int&gt;());\n        \n        Console.Write(sizeof(bool));\n        Console.Write(Marshal.SizeOf&lt;bool&gt;());\n        \n        Console.Write(sizeof(char));\n        Console.Write(Marshal.SizeOf&lt;char&gt;());\n    }\n}",
        answer: "441421",
        explanation: "<code>sizeof(int)</code> and <code>Marshal.SizeOf&lt;int&gt;()</code> both return 4, nothing strange going on there.<br><br><code>sizeof(bool)</code> returns 1 as C# uses 1-byte bools. <code>Marshal.SizeOf&lt;bool&gt;()</code> returns 4 as booleans don't generally have a well-established fixed size in native code. 4 is chosen as a decent default as WinAPI, one of the main uses for P/Invoke, uses 4-byte booleans.<br><br><code>sizeof(char)</code> returns 2 because C# uses UTF-16 characters and string, and <code>Marshal.SizeOf&lt;char&gt;()</code> returns 1 because a C-style ASCII character is assumed.",
        hint: "The <code>sizeof</code> operator returns the C#-native size in bytes of a type. <code>Marshal.SizeOf</code> returns the size in bytes for the purposes of marshalling data, such as when calling into native code.",
        sharpLabUrl: "https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUKgBgAJVMA6AJWmAEsBbAUzIEkpgGwB7ABwGUOAbjQDGDAM4BuPAEhZsvKgDMJdCUwB2PAG9pMjOhlaZ0gMKcoYzgBsmAdTA12ACjE0AXg04AzJzTYBKfylcWTMLazsHZwBZAEMwMQALWKsyXncGAHkvAB4/YAA+J0Dg+RDTc0sbMntHBhcM7ycAI05rEuMwqsi6pziE5NT0j2yc1usijvLOyoiaqPrXDybhZLAp0Nnq2pj4pJS0jNHV+MmgmQBfPAugA==="
    },
];
